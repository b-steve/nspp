#' Simulating Neyman-Scott point process data
#'
#' Simulates point locations from a Neyman-Scott point process.
#'
#' The \code{rchild} function may only take a single distributional
#' parameter. If the distribution for the number of children generated
#' by each parent is Poisson, then the native \code{rpois} is
#' appropriate, as this distribution has a single parameter. For
#' distributions with two or more parameters, those other than
#' \code{child.par} must be hard-coded into \code{rchild}. For
#' example, if a Binomial(n, 2, p) is required, then \code{function(n,
#' p) rbinom(n = n, size = 2, prob = p)} would be an appropriate
#' function for \code{rchild}.
#'
#' @return A matrix containing simulated point locations.
#'
#' @param pars A named vector (or list?) of parameter values. Required
#' parameters are \code{D}, the density of parent points;
#' \code{sigma}, controlling the dispersion of children around their
#' parents; and \code{child.par}, the parameter characterising the distribution for the number of children generated by each parent.
#' @param lims A matrix with two colums, corresponding to the upper
#' and lower limits of each dimension, respectively.
#' @param rchild A function for the generation of random variables
#' from the distribution of the number of children for each
#' parent. The first argument of this function must set the number of
#' random values to generate. The second argument must be the
#' parameter characterising the distribution for the number of
#' children generated by each parent. See 'Details' for more
#' information.
#' @param plot.points Logical, if \code{TRUE}, simulated parent and children
#' point locations will be plotted (only for two dimensions).
#' @param plot.empirical Logical, if \code{TRUE}, the empirical Palm
#' intensity is plotted, with the true Palm intensity from the
#' provided parameters overlain. The latter is only approximate as the
#' mean and variance of the number of children per parent are
#' calculated via simulation from rchild.
#' @param parent.info Logical, if \code{TRUE}, information about the
#' parent points is retained. The object returned is a list with three
#' components: (i) \code{child.locs} contains the locations of
#' children, (ii) \code{parent.id} contains information about which
#' parent generated each child, and (iii) \code{parent.locs} contains
#' parent locations.
#' @param ... Further parameters for rchild.dist.
#'
#' @examples
#' points <- sim.ns(pars = c(D = 20, sigma = 0.025, child.par = 5))
#' 
#' @export
sim.ns <- function(pars = NULL, lims = rbind(c(0, 1), c(0, 1)), rchild = rpois,
                   plot.points = FALSE, plot.empirical = FALSE, parent.info = FALSE){
    ## Allowing lims to be a vector if only one dimension.
    if (!is.matrix(lims)){
        lims <- matrix(lims, nrow = 1)
    }
    ## Parameter values.
    D <- pars["D"]
    sigma <- pars["sigma"]
    child.par <- pars["child.par"]
    ## Number of dimensions.
    n.dims <- nrow(lims)
    ## Calculating survey area.
    area <- prod(apply(lims, 1, diff))
    ## Calculating expected number of parents.
    expected.n.parents <- D*area
    ## Generating number of parents.
    n.parents <- rpois(n = 1, lambda = expected.n.parents)
    ## Error if no parents generated.
    if (n.parents == 0){
        stop("No parents generated.")
    }
    ## Generating parent location points.
    parent.locs <- matrix(0, nrow = n.parents, ncol = n.dims)
    for (i in 1:n.dims){
        parent.locs[, i] <- runif(n.parents, lims[i, 1], lims[i, 2])
    }
    ## Generating the number of children spawned by each parent.
    n.childs <- rchild(n.parents, child.par)
    ## Total number of children.
    n.children <- sum(n.childs)
    ## Error if no children generated.
    if (n.children == 0){
        stop("No children generated.")
    }
    ## Generating children dispersion from parent.
    child.disp <- rmvnorm(n = n.children, mean = rep(0, n.dims),
                          sigma = sigma^2*diag(n.dims))
    child.locs <- matrix(rep(parent.locs, times = rep(n.childs, n.dims)), ncol = n.dims) + child.disp
    ## Adjusting for periodic boundary constraints.
    child.locs <- pbc.fix(child.locs, lims)
    if (plot.points){
        if (n.dims == 2){
            plot.new()
            plot.window(xlim = lims[1, ], ylim = lims[2, ])
            box()
            axis(1)
            axis(2)
            points(child.locs)
            points(parent.locs, pch = 4, lwd = 2, col = "red")
        } else {
            warning("Plotting points only implemented for two dimensions.")
        }
        if (plot.empirical){
            warning("Both 'plot.points' and 'plot.empirical' are TRUE, the latter is being ignored.")
        }
    } else if (plot.empirical){
        xlim <- c(0, 0.5*min(apply(lims, 1, diff)))
        empirical.palm(child.locs, lims, xlim = xlim)
        rs <- rchild(10000, child.par)
        rs.mean <- mean(rs)
        rs.var <- var(rs)
        Dc <- D*rs.mean
        nu <- (rs.var + rs.mean^2)/rs.mean - 1
        analytic.palm(Dc, nu, sigma, n.dims, xlim, add = TRUE, lty = "dashed")
    }
    if (parent.info){
        out <- list(child.locs = child.locs,
                    parent.id = rep(1:n.parents, n.childs),
                    n.child = n.childs,
                    parent.locs = parent.locs)
    } else {
        out <- child.locs
    }
    out
}   

#' Simulating two-dimensional two-plane whale survey data
#'
#' Simulates observed whale locations and plane IDs from a two-plane
#' whale survey.
#'
#' @return A list containing observed animal locations and associated
#'     plane IDs.
#'
#' @param D Animal density.
#' @param sigma Animal dispersion between the passing of planes.
#' @param S Mean duration of surface phase.
#' @inheritParams fit.twoplane
#'
#' @export
sim.twoplane <- function(D, sigma, S, l, w, b, t, C){
    probs <- twoplane.probs(t, C, w, b, S, sigma)
    p.up.down <- probs$p.up.down
    p.down.up <- probs$p.down.up
    p.down.down <- 1 - p.up.down
    p.up.up <- 1 - p.down.up
    p.up <- p.up.down/(p.up.down + p.down.up)
    p.down <- 1 - p.up
    ## Area in which to simulate parents includes 3*sigma buffer.
    lims <- c(0, l)
    parent.lims <- rbind(c(-b - 3*sigma, b + 3*sigma),
                         c(lims[1] - 3*sigma, lims[2] + 3*sigma))
    parent.area <- prod(apply(parent.lims, 1, diff))
    n.parents <- rpois(1, D*parent.area)
    parent.locs <- cbind(runif(n.parents, parent.lims[1, 1], parent.lims[1, 2]),
                         runif(n.parents, parent.lims[2, 1], parent.lims[2, 2]))
    p1.locs <- parent.locs + rnorm(2*n.parents, 0, sigma)
    p2.locs <- parent.locs + rnorm(2*n.parents, 0, sigma)
    p1.up <- sample(c(TRUE, FALSE), size = n.parents, replace = TRUE,
                    prob = c(p.up, p.down))
    p2.up <- logical(n.parents)
    p2.up[p1.up] <- sample(c(TRUE, FALSE), size = sum(p1.up), replace = TRUE,
                           prob = c(p.up.up, p.down.up))
    p2.up[!p1.up] <- sample(c(TRUE, FALSE), size = sum(!p1.up), replace = TRUE,
                            prob = c(p.up.down, p.down.down))
    p1.in.buffer <- (p1.locs[, 2] > lims[1]) & (p1.locs[, 2] < lims[2]) &
        (p1.locs[, 1] > -b) & (p1.locs[, 1] < b)
    p2.in.buffer <- (p2.locs[, 2] > lims[1]) & (p2.locs[, 2] < lims[2]) &
        (p2.locs[, 1] > -b) & (p2.locs[, 1] < b)
    p1.in.zone <- (p1.locs[, 2] > lims[1]) & (p1.locs[, 2] < lims[2]) &
        (p1.locs[, 1] > -w) & (p1.locs[, 1] < w)
    p2.in.zone <- (p2.locs[, 2] > lims[1]) & (p2.locs[, 2] < lims[2]) &
        (p2.locs[, 1] > -w) & (p2.locs[, 1] < w)
    p1.in <- p1.up & p1.in.zone
    p2.in <- p2.up & p2.in.zone
    points <- rbind(p1.locs[p1.in, 2, drop = FALSE],
                       p2.locs[p2.in, 2, drop = FALSE])
    planes <- c(rep(1, sum(p1.in)), rep(2, sum(p2.in)))
    list(points = points, planes = planes)
}
