#' Simulating Neyman-Scott point process data
#'
#' Simulates point locations from a Neyman-Scott point process.
#'
#' The \code{rchild} function may only take a single distributional
#' parameter. If the distribution for the number of children generated
#' by each parent is Poisson, then the native \code{rpois} is
#' appropriate, as this distribution has a single parameter. For
#' distributions with two or more parameters, those other than
#' \code{child.par} must be hard-coded into \code{rchild}. For
#' example, if a Binomial(n, 2, p) is required, then \code{function(n,
#' p) rbinom(n = n, size = 2, prob = p)} would be an appropriate
#' function for \code{rchild}.
#'
#' @return A matrix containing simulated point locations.
#'
#' @param pars A named vector (or list?) of parameter values. Required
#' parameters are \code{D}, the density of parent points;
#' \code{sigma}, controlling the dispersion of children around their
#' parents; and \code{child.par}, the parameter characterising the distribution for the number of children generated by each parent.
#' @param lims A matrix with two colums, corresponding to the upper
#' and lower limits of each dimension, respectively.
#' @param rchild A function for the generation of random variables
#' from the distribution of the number of children for each
#' parent. The first argument of this function must set the number of
#' random values to generate. The second argument must be the
#' parameter characterising the distribution for the number of
#' children generated by each parent. See 'Details' for more
#' information.
#' @param plot.points Logical, if \code{TRUE}, simulated parent and children
#' point locations will be plotted (only for two dimensions).
#' @param plot.empirical Logical, if \code{TRUE}, the empirical Palm
#' intensity is plotted, with the true Palm intensity from the
#' provided parameters overlain. The latter is only approximate as the
#' mean and variance of the number of children per parent are
#' calculated via simulation from rchild.
#' @param parent.info Logical, if \code{TRUE}, information about the
#' parent points is retained. The object returned is a list with three
#' components: (i) \code{child.locs} contains the locations of
#' children, (ii) \code{parent.id} contains information about which
#' parent generated each child, and (iii) \code{parent.locs} contains
#' parent locations.
#' @param ... Further parameters for rchild.dist.
#'
#' @examples
#' points <- sim.ns(pars = c(D = 20, sigma = 0.025, child.par = 5))
#' 
#' @export
sim.ns <- function(pars = NULL, lims = rbind(c(0, 1), c(0, 1)), rchild = rpois,
                   plot.points = FALSE, plot.empirical = FALSE, parent.info = FALSE){
    ## Allowing lims to be a vector if only one dimension.
    if (!is.matrix(lims)){
        lims <- matrix(lims, nrow = 1)
    }
    ## Parameter values.
    D <- pars["D"]
    sigma <- pars["sigma"]
    child.par <- pars["child.par"]
    ## Number of dimensions.
    n.dims <- nrow(lims)
    ## Calculating survey area.
    area <- prod(apply(lims, 1, diff))
    ## Calculating expected number of parents.
    expected.n.parents <- D*area
    ## Generating number of parents.
    n.parents <- rpois(n = 1, lambda = expected.n.parents)
    ## Error if no parents generated.
    if (n.parents == 0){
        stop("No parents generated.")
    }
    ## Generating parent location points.
    parent.locs <- matrix(0, nrow = n.parents, ncol = n.dims)
    for (i in 1:n.dims){
        parent.locs[, i] <- runif(n.parents, lims[i, 1], lims[i, 2])
    }
    ## Generating the number of children spawned by each parent.
    n.childs <- rchild(n.parents, child.par)
    ## Total number of children.
    n.children <- sum(n.childs)
    ## Error if no children generated.
    if (n.children == 0){
        stop("No children generated.")
    }
    ## Generating children dispersion from parent.
    child.disp <- rmvnorm(n = n.children, mean = rep(0, n.dims),
                          sigma = sigma^2*diag(n.dims))
    child.locs <- matrix(rep(parent.locs, times = rep(n.childs, n.dims)), ncol = n.dims) + child.disp
    ## Adjusting for periodic boundary constraints.
    child.locs <- pbc.fix(child.locs, lims)
    if (plot.points){
        if (n.dims == 2){
            plot.new()
            plot.window(xlim = lims[1, ], ylim = lims[2, ])
            box()
            axis(1)
            axis(2)
            points(child.locs)
            points(parent.locs, pch = 4, lwd = 2, col = "red")
        } else {
            warning("Plotting points only implemented for two dimensions.")
        }
        if (plot.empirical){
            warning("Both 'plot.points' and 'plot.empirical' are TRUE, the latter is being ignored.")
        }
    } else if (plot.empirical){
        xlim <- c(0, 0.5*min(apply(lims, 1, diff)))
        empirical.palm(child.locs, lims, xlim = xlim)
        rs <- rchild(10000, child.par)
        rs.mean <- mean(rs)
        rs.var <- var(rs)
        Dc <- D*rs.mean
        nu <- (rs.var + rs.mean^2)/rs.mean - 1
        analytic.palm(Dc, nu, sigma, n.dims, xlim, add = TRUE, lty = "dashed")
    }
    if (parent.info){
        out <- list(child.locs = child.locs,
                    parent.id = rep(1:n.parents, n.childs),
                    n.child = n.childs,
                    parent.locs = parent.locs)
    } else {
        out <- child.locs
    }
    out
}

#' Simulating two-plane whale survey data
#'
#' Simulates observed whale locations and plane IDs from a two-plane
#' whale survey.
#'
#' @return A list containing observed whale locations and associated
#' plane IDs.
#'
#' @param pars A named vector of parameter values. Required parameters
#' are \code{D}, whale density, \code{sigma}, whale movement,
#' \code{p01}, the probability that a whale is on the surface when the
#' second plane flies over, given that it was submerged when the first
#' plane flew over, and \code{10}, the probability that a whale is
#' submerged with the second plane flies over, given that it was on
#' the surface when the first plane flew over.
#' @param lims The limits of the survey transect.
#'
#' @export
sim.twoplane <- function(pars, lims){
    ## Extracting parameters.
    D <- pars["D"]
    sigma <- pars["sigma"]
    p01 <- pars["p01"]
    p10 <- pars["p10"]
    p11 <- 1 - p10
    p00 <- 1 - p01
    ## Simulating number of whales.
    n.whales <- rpois(n = 1, lambda = D*diff(lims[1, ]))
    ## Simulating whale locations for first flyover.
    pos.plane1 <- runif(n.whales, min = lims[1, 1], max = lims[1, 2])
    ## Simulating whale movement.
    movement <- sample(c(-1, 1), size = n.whales, replace = TRUE)*
        sigma*sqrt(2)*sqrt(rchisq(n.whales, 1))
    ## Calculating whale locations for second flyover.
    pos.plane2 <- pos.plane1 + movement
    ## Simulating detections for first flyover.
    det.plane1 <- sample(c(TRUE, FALSE), size = n.whales, replace = TRUE,
                         prob = c(p01/(p10 + p01), p10/(p10 + p01)))
    ## Simulating detections for second flyover.
    det.plane2 <- logical(n.whales)
    det.plane2[det.plane1] <- sample(c(TRUE, FALSE), size = sum(det.plane1),
                                     replace = TRUE, prob = c(p11, p10))
    det.plane2[!det.plane1] <- sample(c(TRUE, FALSE), size = sum(!det.plane1),
                                      replace = TRUE, prob = c(p01, p00))
    ## Concatenating detection locations.
    points <- c(pos.plane1[det.plane1], pos.plane2[det.plane2])
    ## Fixing points for periodic boundary conditions.
    points <- pbc.fix(points, lims)
    planes <- c(rep(1, sum(det.plane1)), rep(2, sum(det.plane2)))
    list(points = points, planes = planes)
}

    

#' Simulating two-dimensional two-plane whale survey data
#'
#' Simulates observed whale locations and plane IDs from a two-plane
#' whale survey.
#'
#' @return A list containing observed whale locations and associated
#'     plane IDs.
#'
#' @param pars A named vector of parameter values. Required parameters
#'     are \code{D}, whale density, \code{sigma}, whale movement,
#'     \code{p.up.down}, the probability that a whale is on the
#'     surface when the second plane flies over, given that it was
#'     submerged when the first plane flew over, and \code{p.down.up},
#'     the probability that a whale is submerged with the second plane
#'     flies over, given that it was on the surface when the first
#'     plane flew over.
#' @param lims The one-dimensional limits of the transect.
#' @param w The distance from the transect and the edge of the
#'     detection zone.
#' @param b The distance from the transect and the edge of the buffer
#'     zone.
#'
#' @export
sim.twoplane.2D <- function(pars, lims, w, b){
    D <- pars["D"]
    sigma <- pars["sigma"]
    p.up.down <- pars["p.up.down"]
    p.down.up <- pars["p.down.up"]
    names(D) <- NULL
    names(sigma) <- NULL
    names(p.up.down) <- NULL
    names(p.down.up) <- NULL
    p.down.down <- 1 - p.up.down
    p.up.up <- 1 - p.down.up
    p.up <- p.up.down/(p.up.down + p.down.up)
    p.down <- 1 - p.up
    ## Area in which to simulate parents includes 3*sigma buffer.
    parent.lims <- rbind(c(-b - 3*sigma, b + 3*sigma),
                         c(lims[1] - 3*sigma, lims[2] + 3*sigma))
    parent.area <- prod(apply(parent.lims, 1, diff))
    n.parents <- rpois(1, D*parent.area)
    parent.locs <- cbind(runif(n.parents, parent.lims[1, 1], parent.lims[1, 2]),
                         runif(n.parents, parent.lims[2, 1], parent.lims[2, 2]))
    p1.locs <- parent.locs + rnorm(2*n.parents, 0, sigma)
    p2.locs <- parent.locs + rnorm(2*n.parents, 0, sigma)
    p1.up <- sample(c(TRUE, FALSE), size = n.parents, replace = TRUE,
                    prob = c(p.up, p.down))
    p2.up <- logical(n.parents)
    p2.up[p1.up] <- sample(c(TRUE, FALSE), size = sum(p1.up), replace = TRUE,
                           prob = c(p.up.up, p.down.up))
    p2.up[!p1.up] <- sample(c(TRUE, FALSE), size = sum(!p1.up), replace = TRUE,
                            prob = c(p.up.down, p.down.down))
    points <- rbind(p1.locs[p1.up, ], p2.locs[p2.up, ])
    in.buffer <- (points[, 2] > lims[1]) & (points[, 2] < lims[2]) &
        (points[, 1] > -b) & (points[, 1] < b)
    points.2D <- points[in.buffer, ]
    planes <- c(rep(1, sum(p1.up)), rep(2, sum(p2.up)))
    planes.2D <- planes[in.buffer]
    in.zone <- (points[, 2] > lims[1]) & (points[, 2] < lims[2]) &
        (points[, 1] > -w) & (points[, 1] < w)
    points.1D <- points[in.zone, 2, drop = FALSE]
    planes.1D <- planes[in.zone]
    list(points.1D = points.1D, planes.1D = planes.1D,
         points.2D = points.2D, planes.2D = planes.2D)
}
